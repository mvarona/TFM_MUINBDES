\apendice{Documentación técnica de programación}\label{programador}

\section{Introducción}

En el presente anexo se detalla la información necesaria para mantener el sistema por otros programadores.

\section{Estructura de directorios}

Tras clonar el repositorio, disponible en \url{https://github.com/mvarona/TFM\_MUINBDES}, se pueden encontrar las carpetas \texttt{Scripts}, \texttt{Data} y \texttt{Web}.

La primera contiene, dentro del directorio \texttt{ETL} (siglas de \texttt{Extracción, transformación y limpieza}) los archivos de Python y PHP con los que se realiza la extracción de datos vía APIs y \textit{Web scraping} y las operaciones de tratamiento de los conjuntos de datos descargados directamente. A su vez, se encuentran también en el directorio \texttt{Scripts} los programas para crear y normalizar el modelo.

Los resultados de las extracciones y procesamientos se encuentran en formato CSV en la carpeta \texttt{Data}. Dentro de esta carpeta están los directorios \texttt{others} y \texttt{support}. En el primero se encuentra la base de datos (el modelo no normalizado) y la base de datos de información extraída de Wikipedia, ambos en formato JSON. Por otra parte, en el segundo directorio se encuentran archivos CSV intermedios o archivos en formato XLSX procedentes de diversos conjuntos de datos.

A continuación, se exponen en orden alfabético los componentes software usados en la fase de ETL. En todos ellos se pasan como parámetros las ubicaciones de los ficheros con los que trabajan:

\begin{enumerate}
    \item \texttt{.env.} Archivo que contiene las credenciales para las APIs de PositionStack, OpenWeather y GeoApify, cuyo uso se detallará en los ficheros correspondientes, y que permite inyectarlas como variables de entorno para que su valor no figure en el repositorio.
    
    \item \texttt{add-coast-mountain-line-to-municipality.py.} Añade a cada municipio la línea en la que se encuentra hasta la costa y la montaña. Con las siguientes particularidades:

    \begin{enumerate}
        \item Se ha empleado la heurística detallada en la tercera sección, ~\ref{Conceptos teóricos}{\guillemotleft Conceptos teóricos\guillemotright}, de esta memoria, por la que los municipios de las provincias costeras presentan la menor distancia a la costa posible (1), y que esta aumenta conforme aumenta la distancia a las provincias costeras desde las provincias a las que pertenecen los municipios, tomando los valores 2 y 3; 2 para los municipios que se encuentran en provincias limítrofes con provincias costeras; y 3 para los limítrofes con estas provincias. En los casos restantes –es decir; en aquellos en los que la distancia a una provincia costera española es superior a dos provincias, o la dificultad para llegar en línea recta es grande, se toma el valor arbitrario 0 para indicar la máxima lejanía. Es el caso de Ávila, Cáceres, Guadalajara, Salamanca y Toledo. Como excepciones, a La Rioja, Soria y Huesca se les asignó la segunda línea costera a pesar de corresponderles la tercera por su facilidad para llegar por carretera, al tratarse de provincias limítrofes a otras de pequeño tamaño.

        \item De forma similar, se ha considerado que un municipio está lo más próximo posible a la montaña (valor 1) si en su provincia se encuentran los principales sistemas montañosos españoles: Cordilleras Béticas, Cordillera Cantábrica, Cordillera Costero-Catalana, Islas Canarias, Macizo Galaico, Meseta Central, Pirineos, Sistema Central y Sistema Ibérico. Los municipios en cuyas provincias se encuentran sistemas montañosos significativos pero no contenidos en la lista anterior, o cuyas provincias son limítrofes con las anteriores, se relacionan con el valor 2; mientras que el valor 3 queda reservado para los municipios de provincias colindantes con las anteriores. De nuevo, el valor 0 se usa en provincias especialmente planas de acuerdo con el informe de rugosidad anteriormente mencionado, y otros datos del relieve español~\cite{relieve}. En particular, estas provincias son las de Badajoz, Cádiz, Huelva, Sevilla, Valencia, Valladolid y la ciudad autónoma de Ceuta.
    \end{enumerate}

    \item \texttt{add-income-to-municipality.py.} Este archivo añade los datos de renta per cápita (procedentes de los CSV y XLSX –convertidos a CSV previamente–) de la Agencia Tributaria para todos los municipios excepto los pertenecientes a las comunidades de País Vasco y Comunidad Foral de Navarra, donde los datos se toman de los organismos Eustat y Hacienda Foral, respectivamente.

    Es importante mencionar que, para los municipios de menos de 1000 habitantes, la Agencia Tributaria facilita datos agregados en vez de individuales, utilizando la denominación \guillemotleft Agrupación municipios pequeños\guillemotright. Como se detallará posteriormente, para los municipios que encajan con este tamaño se tomará este valor como su renta per cápita.

    Para el municipio navarro Castillonuevo, Hacienda Foral no facilitó datos por secreto estadístico, al tratarse de un municipio con 18 habitantes según el padrón de 2021. Por este motivo, se tomaron los datos del municipio más cercano: Bigüézal, de 56 habitantes según el mismo padrón.

    \item \texttt{add-province-employment-to-municipality.py.} Añade a cada municipio los datos de empleo (tasa de actividad, tasa de empleo, tasa de desempleo y número de empleos disponibles) de la provincia a la que pertenece cada uno.
    
    \item \texttt{add-province-prices-to-municipality.py.} Añade a cada municipio los datos de viviendas (precio medio del metro cuadrado a la venta, precio medio de las viviendas a la venta, precio medio del metro cuadrado en alquiler y precio medio de las viviendas en alquiler) de las provincias a los que pertenecen.
    
    \item \texttt{add-region-to-municipality.py.} Añade a cada municipio la comunidad autónoma a la que pertenece.
    
    \item \texttt{build-municipality-human-name.py.} Construye para cada municipio su nombre común; es decir, convierte las partes separadas por comas o paréntesis (\textit{Coruña, A}; \textit{Hospitalet de Llobregat, L'}) en la parte inicial del nombre (\textit{A Coruña}; \textit{L' Hospitalet de Llobregat}). Es necesario para poder establecer comparaciones entre distintas fuentes de datos, ya que casi ninguna utiliza el código numérico identificativo del INE.
    
    \item \texttt{clean-schools-municipality.py.} Dado que los datos de centros de educación primaria y secundaria que facilita el Ministerio de Educación corresponden a entidades singulares de población y provincia, y no a municipios, una vez se ha realizado la asociación de cada entidad singular al municipio correspondiente, este archivo limpia el fichero CSV para eliminar las entidades singulares y contar solo con municipio, número de colegios y provincia a la que pertenece.
    
    \item \texttt{complete-nsi-codes.py.} Añade los ceros iniciales a los códigos del INE de menos de cinco cifras, que pueden perderse en algún tratamiento que opera con ellos tratándolos como enteros en vez de como cadenas de texto. El nivel de cinco cifras es el asociado a municipios en la jerarquía del código de 11 cifras del INE.
    
    \item \texttt{complete\_municipalities\_codes.py.} Relacionado con estos códigos, este archivo recibe un fichero CSV y completa los códigos de municipio ausentes con un fichero de referencia que los contenga, basándose en el nombre del municipio y en la provincia a la que pertenece. Ha permitido homogeneizar los datos cuando estos proceden de diversas administraciones o de entidades privadas que no usan los códigos identificativos.
    
    \item \texttt{corsnavigator.php}. Archivo pensado para evadir las restricciones de origen en el control de acceso a sitios Web. El archivo fue subido al servidor personal, y únicamente declara las siguientes cabeceras y carga el contenido de la Web pasada como argumento \texttt{url} de tipo POST:
    \begin{verbatim}
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: POST, GET, OPTIONS');
    \end{verbatim}
    
    De esta manera, se consigue poder cargar contenido de fuentes externas haciendo una llamada al servidor propio, lo que ha permitido las labores de extracción Web en varias ocasiones.

    \item \texttt{discard-fields.py.} Descarta las columnas especificadas de un archivo CSV, dado que en algunas ocasiones ha sido necesario prescindir de algunos datos de los conjuntos manejados (número de declarantes o posicionamiento del municipio a nivel autonómico en cuanto a su renta bruta media, por ejemplo).
       
    \item \texttt{encode-places.py.} Codifica los sitios más repetidos en un municipio (separados por punto y coma, puede haber hasta tres, según el proveedor de API geográfica usado) como valores binarios en tantas columnas como posibles categorías hay; es decir, en notación \textit{one hot encoding}.
    
    \item \texttt{extract-universities.html}. Extrae el número de centros de educación superior presentes en cada municipio del portal del Ministerio de Educación. A diferencia del resto de extracciones Web, se realizó mediante código JavaScript en un archivo HTML –por tanto, ejecutándose desde el navegador en vez de desde la línea de comandos– por ser el primer caso de \textit{Web scraping} que se llevó a cabo y disponer de mayor familiaridad con las técnicas frente a Python. Sin embargo, esta tecnología fue rápidamente descartada para el resto de casos debido a la mayor comodidad, facilidad de depuración y rendimiento que ofrece la segunda tecnología, que puede ser lanzada desde la línea de comandos y no bloquea el navegador Web.

    El proceso para extraer el número de municipios fue el siguiente: En primer lugar, se debe acceder al Registro de Universidades, Centros y Títulos (RUCT) del Ministerio de Educación, en particular, a la sección que contiene todos los centros, sabiendo que están paginados en 198 páginas.

    Posteriormente, y conociendo la URL de cada página del anterior listado, se extrae el código de universidad y el código de centro de cada fila, para finalmente componer la URL de cada centro, que usa ambos códigos. Desde esta dirección es posible saber en qué municipio está cada centro y a qué universidad pertenece, de forma que posteriormente es trivial agruparlos por universidades y municipios, y realizar su sumatorio para devolver el número de universidades (centros de educación superior) por municipio.

    \imagen{unis4}{Página de detalle de cada centro, compuesta a partir de los códigos de universidad y centro anteriores.}
    
    \item \texttt{fix-incomes.py.} Inicialmente se cometió un error en la asignación de rentas de municipios pertenecientes al País Vasco, dado que se confundió renta per cápita con renta familiar, resultando en valores anómalamente superiores que fueron detectados en la parte de exploración de esta fase. Como consecuencia, fue necesario recopilar los datos correctos de renta per cápita de la oficina de estadística vasca, y crear este guión para sustituirlos en el fichero correspondiente.

    \item \texttt{geocode-municipalities.py.} Emplea la API de PositionStack para devolver la latitud y longitud dados un nombre de un municipio y su provincia. Se ha empleado este servicio dado que, tras realizar el análisis de costes de varias alternativas, ofrecía una cuota gratuita considerablemente más generosa que otras alternativas comerciales más conocidas.
    
    Cabe destacar que fueron necesarias dos iteraciones, dado que en la primera se omitió añadir \guillemotleft\texttt{, España}\guillemotright\space como parte final de la dirección física a geolocalizar, lo que provocó que se devolvieran resultados de otras partes del mundo, como América Latina, Estados Unidos u otros territorios.

    \imagen{darrinward}{Exploración de los datos de geolocalización tras la primera iteración.}

    De nuevo, estos valores incorrectos fueron detectados en la exploración de los datos gracias a la herramienta citada anteriormente, lo que permitió su corrección en la segunda pasada.
    
    \item \texttt{get-distance-province-capital.py.} Este fichero calcula la distancia por carretera desde un municipio (sus coordenadas de latitud y longitud) hasta su capital de provincia (también geolocalizada). El cálculo se realiza por medio de OpenTripPlanner (OTP), y en los casos en los que no es posible obtener un resultado (por ejemplo, territorios insulares), se toma la distancia geodésica a través de GeoPy.

    Para realizar estos cálculos se llevó a cabo el siguiente proceso: En primer lugar, es necesario tener geolocalizados todos los municipios, y conocer la provincia a la que pertenecen y su capital. Posteriormente, se descargó la última versión de OTP, distribuida como un fichero JAR (\textit{Java Archive}, por sus siglas en inglés), junto con el mapa de España suministrado por Geofabrik~\cite{spain_map} en formato OSM PBF (\textit{OpenStretMap Protocolbuffer Binary Format}, formato binario de ProtocolBuffer –formato de compresión muy eficiente, como se vio en la asignatura \guillemotleft Infraestructura para el Big Data\guillemotright\space– de OpenStreetMap).

    Acto seguido se utilizó la herramienta BoundingBox, de Klokan Technologies~\cite{klokan}, para obtener las coordenadas geográficas de la caja que rodea al mapa de España, para convertir el mapa a formato PBF con el siguiente comando de la utilidad de Unix osmconvert, indicando que queremos todas las vías que puedan quedar cortadas por los bordes de la caja:

    \begin{verbatim}
osmconvert spain-latest.osm.pbf -b=-18.39,27.43,4.59,43.99
--complete-ways -o=spain.pbf
    \end{verbatim}

    A continuación, iniciamos el servicio de OTP, que levanta un servidor local de Java en el puerto 8080 de nuestro ordenador. Es importante señalar que estas labores se realizaron en otro ordenador a disposición del alumno, dado que se requería más potencia que la de su máquina personal. En particular, fueron necesarios 28 GigaBytes de memoria RAM para poder arrancar el servidor Java usando el mapa de España completo, debido al tamaño de este. Esto se consiguió ejecutando el siguiente comando desde el directorio que contiene el fichero JAR y el mapa en formato PBF, que asigna dicha memoria a la máquina virtual de Java:

    \begin{verbatim}
java -Xmx28G -jar otp.jar
    \end{verbatim}

    \imagen{otp1}{Inicio del servidor de OpenTripPlanner en la segunda máquina del alumno.}

    Pasados unos minutos, la inicialización del servidor se completa, lo que permite ejecutar el servicio Web de enrutado entre ubicaciones de OTP, que cuenta con la siguiente interfaz gráfica:

    \imagen{otp_ruta}{Interfaz gráfica del servicio de OpenTripPlanner.}

    Como las dos máquinas del alumno se encuentran en la misma red, es posible acceder a este servicio desde la máquina que contiene el repositorio vía su dirección IP. Tras realizar la depuración correspondiente a través de la herramienta de manejo de APIs Postman, se procedió a realizar las solicitudes correspondientes y extraer la distancia del itinerario en kilómetros.

    En el caso de los municipios cuya distancia por carretera no fue posible calcular, fue trivial obtener el cálculo de la distancia geodésica que los separa a través de la biblioteca GeoPy.    
    
    \item \texttt{get-elevation.py.} Dado un fichero con coordenadas geográficas, recupera la altitud sobre el nivel del mar de ese punto a través de la API de OpenElevation.
    
    \item \texttt{get-failed-properties.py.} En el proceso de extracción de datos sobre propiedades inmobiliarias (venta y alquiler de viviendas en municipios y provincias) fallaron municipios de nombre compuesto, por ejemplo \guillemotleft Alicante/Alacant\guillemotright, por lo que se usó este archivo para realizar subconjuntos de estos nombres, con la intención de repetir el proceso con el primer nombre (\guillemotleft Alicante\guillemotright), o con el segundo (\guillemotleft Alacant\guillemotright), para obtener el mayor número posible de datos. Esto es así ya que no existe consenso sobre qué nombre debe escribirse primero, y depende del criterio –muchas veces arbitrario– de la fuente de datos elegida.
    
    \item \texttt{get-first-name.py.} Relacionado con el propósito anterior, en algunos momentos ha sido necesario extraer el primer nombre en los municipios con varios nombres.
    
    \item \texttt{get-missing-fields.py.} Añade campos de un subconjunto de datos a otros. Se ha usado para unir subconjuntos de datos intermedios sin claves comunes.
    
    \item \texttt{get-municipality-from-singular-entity.py.} Devuelve el municipio asociado a una entidad singular de población, necesario para algunos conjuntos de datos, como los de centros de educación primaria y secundaria del Ministerio de Educación.
    
    \item \texttt{get-places.py.} Devuelve los tres tipos de lugares de interés más frecuentes y el primero de ellos en otra columna, por razones de comodidad y para facilitar su posterior exploración de datos, a través de la API de GeoApify.

    Para ello, se solicita al proveedor los 20 (valor por defecto e involucrado en la facturación del servicio) lugares de interés en un radio de 5 kilómetros alrededor de las coordenadas especificadas de entre las siguientes categorías: comercios, turismo, alojamientos, ocio, naturaleza, servicios, actividades, entretenimiento, hostelería y deporte.

    Cabe destacar que, pese a que se solicitaron las mencionadas categorías, el servicio devolvió también lugares pertenecientes a las siguientes clases que, al igual que en las anteriores, se han traducido al castellano para facilitar su lectura en este trabajo:

    \begin{enumerate}
        \item Edificio. Comprende edificaciones de cualquier clase, habitualmente con fines prácticos.
        \item Acceso limitado. Abarca lugares de acceso al público limitado.
        \item Artificial. Está formada por construcciones humanas.
        \item Acceso. Son lugares de acceso público.
        \item Sin acceso. Son lugares de acceso privado, sin acceso público.
        \item Patrimonio. Abarca lugares de interés patrimonial.
        \item Carretera. Comprende vías de comunicación por carretera.
        \item Cuota. Está formada por lugares que exigen el pago de una cuota de socio para poder entrar.
        \item Comodidad. Son utilidades públicas de conveniencia, como baños públicos.
    \end{enumerate}
    
    Pese a que algunas pueden parecer algo subjetivas y de definición algo abstracta según la documentación del servicio, se consideró beneficioso tenerlas en cuenta para aumentar los datos sobre los municipios.

    El servicio devuelve los, como máximo, 20 lugares de mayor interés encontrados, con los datos de sus categorías correspondientes. A continuación, se crea para cada municipio un diccionario de clave-valor, donde la clave es el tipo de lugar, y el valor es el número de lugares encontrados que pertenecen a dicha categoría.

    Finalmente, estos diccionarios se agrupan y ordenan por valor de forma descendente para devolver los tipos más recurrentes.

    \item \texttt{get-properties-for-rent.py.} Extrae el precio medio del metro cuadrado en las viviendas en alquiler, el precio medio del alquiler y el número de viviendas en alquiler para los municipios consultados del portal inmobiliario Web Idealista.

    Para ello, construye la URL según el convenio usado por Idealista (nombre del municipio y provincia), y realiza una petición idéntica a la que realizaría un navegador Web humano. Esto es debido a las medidas de seguridad de Idealista para evitar tráfico automático, que exigen enviar datos como una \textit{cookie} de sesión o un identificador único de usuario. Estos datos se tomaron realizando una primera petición desde el navegador de forma manual e inspeccionando el contenido intercambiado en las cabeceras de los paquetes de red.

    Posteriormente, extrae los datos mencionados leyendo el contenido de la página y utilizando los selectores HTML adecuados a través de \textit{beautifulsoup4}. Los valores promedio por superficie se calculan dividiendo el precio entre el número de metros cuadrados de cada vivienda, para después realizar su media aritmética; mientras que el precio medio del alquiler se calcula sumando los valores encontrados en la página inicial y dividiéndolos entre el número de viviendas encontradas en dicha página. Por otra parte, el número de viviendas viene dado como literal y su extracción es trivial.

    Cabe señalar que, con la intención de evitar causar molestias, disrupciones de servicio o violar los términos y condiciones de este tercero, entre petición y petición el programa realiza una pausa de dos segundos para asemejarse lo máximo posible a un visitante humano cuyo tráfico pueda manejar el servidor fácilmente.

    Sin embargo, cuando se habían realizado algo más de 4000 peticiones (el 50 \% de todas las necesarias, dado que se necesita una por municipio) el servicio comenzó a bloquear el tráfico desde la IP del alumno, devolviendo un error HTTP 429, indicando la realización de demasiadas peticiones.

    Por este motivo fue necesario repetir la búsqueda con el subconjunto fallido, dejando pasar un tiempo prudencial tras el que se eliminó la restricción de llamadas.

    \imagen{idealista}{Error HTTP 429 del portal Idealista a partir del 50 \% del proceso durante la primera iteración.}

    Recalcar que esta no es la manera idónea de realizar extracciones de datos para el autor, pero lamentablemente el portal no dispone de una API pública, y fueron varias las opiniones negativas encontradas sobre la elevada dificultad e incertidumbre en el uso de la API privada (previa aprobación del portal), dado que tampoco se encuentra documentada. En cualquier caso, se enfatiza el uso de estos datos para fines exclusivamente educativos, como es la realización de este trabajo académico, y se recomienda la opción de contactar con este tipo de portales de cara a buscar la solución que mejor se adapte a las necesidades del interesado, como comprar los informes de datos del mercado inmobiliario que ellos mismos venden si se desea explotar este aspecto comercialmente.

    La extracción de estos datos se realizó gracias a este programa de forma automática en 10 horas no consecutivas (considerando las dos pasadas necesarias).

    \item \texttt{get-properties-for-rent-fotocasa.py.} De forma análoga al programa anterior, este fichero realiza la extracción de datos del alquiler para municipios usando el servicio de Fotocasa.

    Se usó de forma auxiliar cuando no fue posible recuperar algún dato con Idealista y a modo de prueba comparativa, dado que el coste de crearlo fue considerado residual frente a los beneficios de probar otro proveedor. La formación de la URL del municipio y la extracción de sus datos es prácticamente idéntica, y este portal –aunque con menores datos que el anterior– se comportó mejor a nivel de rendimiento, no limitando las peticiones del alumno en ningún momento (que también estuvieron pausadas, esta vez con un segundo entre ellas, por los mismos motivos anteriores).

    \item \texttt{get-properties-for-sale.py.} Este archivo contiene el mecanismo equivalente al descrito anteriormente para extraer los datos de propiedades inmobiliarias en venta del portal Idealista, tomando los precios medios por metro cuadrado, el precio promedio de las viviendas a la venta y el número total de ellas disponibles por municipio.

    \item \texttt{get-properties-for-sale-fotocasa.py.} Este programa realiza la misma extracción anterior, pero usando el portal Web inmobiliario Fotocasa.

    \item \texttt{get-province-sales-rent-prices.py.} Extrae los precios medios y los precios medios por metro cuadrado de las viviendas en venta y en alquiler de cada provincia a través de las páginas provinciales de Fotocasa. Sigue la misma lógica descrita en los casos anteriores, pero con mucha menos complejidad, ya que únicamente existen 52 provincias frente a los 8131 municipios españoles.

    \item \texttt{get-weather.py.} Extrae los datos climáticos considerados como más representativos dado un municipio geolocalizado, a través del servicio de OpenWeather.

    Tras considerar varias alternativas, se optó por este servicio por el recuerdo de buenas experiencias pasadas con la cantidad y calidad de los datos, y con la facturación. El análisis de viabilidad previo al comienzo de esta extracción confirmó que era posible obtener los datos deseados gratuitamente con la licencia de estudiantes de esta plataforma. Tras solicitarla por seis meses, se exploró la API, que devuelve los datos climáticos históricos de los que dispone OpenWeather (referente en  observación y predicción meteorológica) para una latitud y una longitud concreta en un día, mes o año concretos.
    
    Las opciones de día (el tiempo histórico para un día dado) o año (el tiempo durante un año concreto) no parecen muy significativas para este proyecto, a diferencia de la opción mensual, que devuelve el tiempo histórico registrado en un lugar durante dicho mes.
    
    Sin embargo, el plan mediano de datos históricos incluido en la licencia de estudiante de este servicio, limita el número de llamadas diarias a 50 000, lo que imposibilita recoger datos de todos los meses para cada municipio y procesarlos después –dado que serían necesarias 12 llamadas por cada municipio, unas 97 572–. Por este motivo y debido a las restricciones de recursos de este trabajo, se optó por recoger datos de dos de los meses más significativos del año en nuestro país: febrero y julio, con el objetivo de representar los datos de invierno y verano de forma acusada.    
    
    Cabe señalar que el servicio devuelve los datos de temperaturas en Kelvin y los datos de velocidad del viento en metros por segundo. Ambos se convierten a las unidades habituales en España (grados centígrados y kilómetros por hora, respectivamente) para poder realizar adecuadamente las tareas de exploración de los datos.
    
    \item \texttt{get-wikipedia.py.} Recupera para cada municipio un extracto de texto e imágenes representativas de su entrada en Wikipedia. Esta información no se usa en el modelo pero sí en la presentación e interpretación de los resultados para el usuario.

    Para ello, toma el nombre \guillemotleft humano\guillemotright\space del municipio (sin comas ni paréntesis, como se ha comentado anteriormente) y lo busca junto con el nombre de su provincia en la Wikipedia en español, tomando el primer resultado.
    
    A partir de ahí, extrae el resumen del artículo y las fotografías que aparecen en él, con algunas particularidades: Con el objetivo de mostrar imágenes útiles y visualmente atractivas, descarta aquellas que contienen los siguientes términos en su nombre, sin distinción de mayúsculas o minúsculas: \textit{flag, coat, bandera, escudo, icon, logo, svg}, omitiendo muchas imágenes de escudos, banderas o mapas. Posteriormente, y por razones de rendimiento, toma las primeras 10 imágenes.
    
    En algunos casos es necesario tomar el nombre de la provincia en castellano (\guillemotleft Islas Baleares\guillemotright, en vez del uso muy extendido \guillemotleft Illes Balears\guillemotright), ya que los segundos provocaron mayor número de resultados incorrectos (dado que la enciclopedia devolvía entradas no relacionadas con los municipios, sino con personas, instituciones o empresas).
    
    Dado que, debido al volumen de datos, es un contenido no supervisado y ampliamente cualitativo, su exploración automática ha sido más complicada. Por este motivo, en la sección de \guillemotleft Metodología\guillemotright\space del resultado final –en la que también se explica en líneas generales cómo se ha realizado el proyecto– se indica este hecho, así como la posibilidad de contactar con el autor para informar de información errónea que no haya podido ser detectada antes.
    
    Los resultados se exportan a un fichero en formato JSON.

    \item \texttt{group-clinics-by-municipality.py.} Toma los datos de centros sanitarios del Ministerio de Sanidad y los agrupa por municipio y provincia, ya que estos vienen desglosados por localidad, haciendo referencia a la entidad singular de población. Posteriormente, descarta las columnas no relevantes, como dirección, código postal o área de salud, para realizar el sumatorio del número de centros de salud por municipio.

    \item \texttt{group-connectivity-by-municipality.py.} Toma los datos de conectividad del Ministerio de Asuntos Económicos y Transformación Digital y los agrupa por municipio y provincia, ya que estos vienen desglosados por entidades singular de población.

    \imagen{cobertura}{Archivo Excel con los datos de cobertura de Internet de banda ancha por entidades singulares de población del Ministerio de Asuntos Económicos y Transición Digital.}
    
    Previamente fue necesario asociar a cada entidad singular de población su municipio, según se ha explicado anteriormente.

    \imagen{entidades2}{Archivo Excel con la relación entre las entidades singulares de población y el municipio al que pertenecen de Francisco Ruiz.}
    
    A continuación, realiza el promedio de los valores porcentuales del territorio de cada municipio cubierto por una determinada cobertura, para las siguientes conectividades: fibra óptica de 30 megabytes de velocidad o superiores, fibra óptica de 100 megabytes de velocidad o superiores, red móvil de tercera generación (3G HSPA) y red móvil de cuarta generación (4G LTE).

    \item \texttt{group-emergencies-by-municipality.py.} Toma los datos del Ministerio de Sanidad y los agrupa por municipio y provincia, ya que estos vienen desglosados por localidad, haciendo referencia a la entidad singular de población. Posteriormente, realiza el sumatorio del número de centros de salud con servicio de urgencias extrahospitalarias por municipio.

    \item \texttt{group-hospitals-by-municipality.py.} Toma los datos de centros sanitarios del Ministerio de Sanidad y los agrupa por municipio y provincia, ya que estos vienen desglosados por localidad, haciendo referencia a la entidad singular de población. Posteriormente, descarta las columnas no relevantes, como dirección, código postal o área de salud, para realizar el sumatorio del número de hospitales de gestión pública o privada por municipio.
    
    \item \texttt{group-schools-by-municipality.py.} Toma los datos de centros educativos del Ministerio de Educación y los agrupa por municipio para realizar el sumatorio del número de centros educativos por municipio.
    
    \imagen{entidades1}{Archivo Excel con los datos de centros educativos por entidades singulares de población del Ministerio de Educación.}
    
    \item \texttt{merge-properties.py.} Fusiona los datos de las distintas iteraciones necesarias para recuperar los datos de propiedades inmobiliarias de los portales Idealista y Fotocasa.
    
    \item \texttt{merge.py.} Fusiona los ficheros con los resultados parciales obtenidos de las distintas extracciones anteriores para formar un fichero que los agrupe a todos y que constituirá el modelo posterior.
    
    \item \texttt{random-sample-csv.py.} Extrae una muestra aleatoria de tamaño variable de un fichero de municipios pasado como argumento, de forma que pueda usarse para probar y depurar las distintas funciones de extracción.
\end{enumerate}

Los archivos descritos se pueden encontrar en el directorio \texttt{Scripts/ETL} del repositorio entregado, y además de los mismos, también se quiere hacer mención a los siguientes ficheros auxiliares usados durante este proceso y que se subieron al servidor personal del alumno para poder realizar labores de depuración sin incurrir en costes adicionales en los servicios de terceros:

\begin{itemize}
    \item \texttt{geocoder-mock.php.} Contiene un ejemplo de respuesta para un municipio del servicio usado como proveedor de geocodificación, de forma que se pudiera probar la lógica que extrae la latitud y longitud del municipio sin llamar al servicio real.
    \item \texttt{places-mock.php.} Muestra un ejemplo de respuesta para los lugares de interés encontrados en un municipio por el proveedor de servicios de localización, para probar y depurar la lógica relacionada sin alcanzar el servidor de GeoApify, evitando gastos innecesarios.
    \item \texttt{planner-mock.php.} Constituye un ejemplo de respuesta del servicio OpenTripPlanner para el cálculo de ruta entre dos coordenadas geográficas, de forma que se pudiera probar la lógica que calcula la distancia entre un municipio y su capital de provincia sin usar el servicio real.
    \item \texttt{villares.html.} Página de un municipio del resultado software final, utilizada para probar desde un navegador real cómo se visualizaría la página desde Internet –y no desde \textit{localhost}– antes de iniciar la fase de despliegue.
\end{itemize}

El directorio \texttt{Web} contiene todo lo relacionado con el producto desplegado. Destacan las carpetas \texttt{api}, con los archivos usados en el servidor secundario de pila LAMP; \texttt{templates}, con las plantillas de Jinja2 usadas por Flask; y \texttt{static}, que contiene las páginas estáticas del sistema y los archivos necesarios para interpretarlas en el navegador. Esto incluye las páginas de cada municipio, presentes en la subcarpeta de su provincia dentro de la carpeta \texttt{municipios}, los archivos de estilo CSS y de JavaScript necesarios para la interacción enriquecida con el sitio Web y las imágenes mostradas alojadas directamente en el servidor. En particular, la creación de la página Web que sirve como resultado final accesible de este trabajo ha conllevado la creación de los siguientes archivos y ficheros:

\subsubsection{Directorio principal}

\begin{itemize}
	\item \texttt{.env}. Archivo de variables de entorno para el entorno local.
	\item \texttt{.gcloudignore}. Especifica los archivos que no se subirán a la plataforma de Google, como los archivos de caché de Python o PHP.
	\item \texttt{api/}. Directorio que contiene los archivos alojados en el servidor LAMP, que se detallarán posteriormente.
	\item \texttt{app.yaml}. Archivo de configuración de la aplicación en Google App Engine. Especifica parámetros como el tipo de instancia en el que se ejecutará, el esquema de las URL y si siempre aplicará HTTPS.
	\item \texttt{database.csv}. Base de datos del trabajo creada anteriormente, alojada en la plataforma Web para que los \textit{scripts} puedan acceder a ella fácilmente.
	\item \texttt{database.json}. Base de datos creada anteriormente, en formato JSON para su acceso y manejo cómodo por diversos \textit{scripts}. Cabe destacar que, aunque se aloje en la plataforma, no se expone al público, dado que no está en el directorio público \guillemotleft static\guillemotright\space ni es accesible de otra manera que a través de \textit{endpoints} (funciones del archivo enrutador) que exponen únicamente subconjuntos, como los nombres de los municipios para la función de autocompletado. Esto es así para evitar que un usuario malintencionado pueda acceder al conjunto de datos del sistema y pueda crear una réplica del sistema sin coste.
	\item \texttt{env.yaml}. Archivo de variables de entorno para Google App Engine.
	\item \texttt{get\_municipalities\_list\_for\_autocomplete.py}. Obtiene la lista de municipios y sus provincias con la que el cliente Web (\textit{frontend}) construye el autocompletado para el usuario.
	\item \texttt{get\_municipality.py}. Por razones de eficiencia y comunicación, y aplicando principios vistos en las asignaturas \guillemotleft Modelos de programación para el Big Data\guillemotright, \guillemotleft Infrastructuras Big Data\guillemotright\space y \guillemotleft Arquitecturas Big Data\guillemotright, cuando algún recurso necesita trabajar con municipios maneja únicamente la información imprescindible para identificarlos; esto es, su identificador únivoco del INE. De esta forma, se reduce enormemente la latencia de red y se acelera la velocidad de los cálculos, además de mejorar la eficiencia del sistema (consume menos recursos y, por tanto, el coste de la instancia de Google en ejecución es menor). Como último paso antes de mostrar la información al usuario, este archivo devuelve la información de un municipio dado su código identificativo.
	\item \texttt{main.py}. Es el archivo enrutador de Flask y controlador del flujo de ejecución para las peticiones de los usuarios. Ante una petición concreta, llama a otras funciones para proveer al sitio Web de comportamiento dinámico.
	\item \texttt{make\_decimal\_numbers.py}. Usado para convertir los números decimales en inglés (punto como separador decimal, \guillemotleft .\guillemotright) al español (coma como separador, \guillemotleft ,\guillemotright).
	\item \texttt{model\_normalized.csv}. Modelo normalizado creado anteriormente, alojado en la plataforma Web para que los \textit{scripts} puedan acceder a él.
	\item \texttt{random\_municipality.py}. Devuelve un municipio aleatorio.
	\item \texttt{ratings\_manager.py}. Gestiona el archivo de valoraciones de los usuarios, emitiendo una valoración positiva o negativa para un usuario y un municipio.
	\item \texttt{recommender.py}. Constituye el motor del recomendador basado en contenido. Devuelve los 10 municipios más similares a aquel que se introduce.
	\item \texttt{requirements.txt}. Archivo que especifica las librerías de las que depende el proyecto, y que permiten montarlo en Google App Engine.
	\item \texttt{sanitize\_names.py}. Convierte el nombre de un municipio al nombre esperado en las URL del sistema. Esencialmente, sustituye tildes, eñes, preposiciones... De esta forma, devuelve que el municipio de Albacete \guillemotleft Alcalá del Júcar\guillemotright\space se puede encontrar en \guillemotleft albacete/alcala-del-jucar\guillemotright.
	\item \texttt{sitemap.xml}. Mapa del sitio para ayudar a los buscadores en su indexación, importante dado el número de municipios existentes con su propia página, a fin de tener un buen posicionamiento Web y facilitar la compartición de enlaces entre los usuarios.
	\item \texttt{static/}. Directorio que contiene los archivos estáticos de las páginas Web, como se detallará posteriormente.
	\item \texttt{survey.py}. Procesa las respuestas de los usuarios al cuestionario y filtra los municipios según los criterios especificados, devolviendo un elemento aleatorio del subconjunto final resultante.
	\item \texttt{templates/}. Directorio que contiene plantillas de Jinja2 con los huecos necesarios para formar la vista final.
	\item \texttt{user\_suggestions.py}. Constituye el motor del recomendador colaborativo basado en ítems.
	\item \texttt{users\_recommendations.py}. Es el motor del recomendador colaborativo basado en usuarios.
	\item \texttt{wikipedia.json}. Archivo con la información extraída de Wikipedia para cada municipio, en formato JSON para su fácil carga por el código JavaScript.

\end{itemize}

\subsubsection{Directorio \guillemotleft api\guillemotright\space}

\begin{itemize}
	\item \texttt{.env}. Archivo de variables de entorno para el servidor LAMP.
	\item \texttt{.htaccess}. Protege los ficheros del directorio para que ningún usuario a excepción del propietario pueda acceder a los archivos alojados en el directorio \guillemotleft storage\guillemotright; y que únicamente puedan hacerlo archivos PHP alojados en el mismo servidor.
	\item \texttt{DotEnv.php}. Biblioteca externa usada para la gestión de variables de entorno en PHP.
	\item \texttt{generate-user-id.php}. Genera un identificador único aleatorio de 32 caracteres para el usuario que no tiene la \textit{cookie} con él instalada y que ha dado su consentimiento, como se explicará posteriormente. 
	\item \texttt{get-ratings.php}. Previa compartición de una clave única segura con ella, expone a la aplicación el archivo de valoraciones de usuarios.
	\item \texttt{get-suggestions.php}. Previa compartición de una clave única segura con ella, expone a la aplicación el archivo de sugerencias calculado cada día.
	\item \texttt{rate.php}. Previa compartición de una clave única segura con ella, realiza la anotación de la valoración del usuario indicada por la aplicación.
	\item \texttt{storage/}. Directorio de almacenaje, que resuelve la dificultad para almacenar y actualizar archivos de texto en aplicaciones como servicio como Google App Engine.
	\item \texttt{update-suggestions.php}. Previa compartición de una clave única segura con ella, actualiza las recomendaciones de los usuarios del filtro colaborativo basado en ítems. 

\end{itemize}

\subsubsection{Directorio \guillemotleft api/storage\guillemotright\space}

\begin{itemize}
	\item \texttt{ratings.csv}. Archivo de valoraciones de los usuarios.
	\item \texttt{suggestions.json}. Archivo de sugerencias para los usuarios, actualizado cada día.
	\item \texttt{users.csv}. Base de datos de usuarios que permite la generación de identificadores únicos.

\end{itemize}

\subsubsection{Directorio \guillemotleft static\guillemotright\space}

\begin{itemize}
	\item \texttt{css/}. Directorio con los ficheros de estilo de las páginas Web.
	\item \texttt{images/}. Directorio con las imágenes de fondos aleatorios descargadas, u otros recursos, como logotipos o iconos.
	\item \texttt{js/}. Directorio con los ficheros de JavaScript para permitir la interacción del usuario y enriquecer su experiencia.
	\item \texttt{robots.txt}. Archivo con información para los buscadores de Internet, referenciando el mapa del sitio, y pidiendo la no indexación de las páginas de error.
    \item \texttt{municipios/}. Contiene las páginas de información para los 8131 de España, agrupados en 52 subcarpetas según su provincia.

\end{itemize}

\subsubsection{Directorio \guillemotleft templates\guillemotright\space}

\begin{itemize}
	\item \texttt{404.html}. Página de error para una solicitud de un recurso no encontrado.
	\item \texttt{base.html}. Página plantilla para todas las demás, conteniendo el esqueleto de todas: encabezado, contenido a reemplazar y pie.
	\item \texttt{metodologia.html}. Página usada para explicar cómo se ha realizado el ejecutable, las fuentes del trabajo y cómo contactar si se desea obtener más información.
	\item \texttt{privacidad.html}. Política de privacidad en función del uso de datos de los usuarios, generada con la herramienta de Zimrre \& Freelance~\cite{privacidad}.
	\item \texttt{soon.html}. Página de muestra utilizada desde que se adquirió el dominio, para garantizar su disponibilidad, y hasta que el desarrollo del sistema estuvo completado.
	\item \texttt{500.html}. Página de error para un fallo del servidor.
	\item \texttt{home.html}. Página de inicio.
	\item \texttt{municipality.html}. Página de plantilla para cada municipio, a partir de las que se generan localmente las propias para cada uno, que se guardan y se suben a la plataforma para que estén disponibles de forma estática, por los motivos de posicionamiento, visibilidad y compartición mencionados anteriormente. Además de la información recolectada durante la elaboración del modelo, en los municipios de Castilla y León se muestra también la agenda cultural para los próximos días en un radio de 10 kilómetros, utilizando los datos abiertos de la Junta de Castilla y León~\cite{agenda}, para probar el grado de adaptabilidad del sistema a nuevos requisitos.
	\item \texttt{similar.html}. Página para la introducción del municipio para el que se genera la recomendación basada en contenido.
	\item \texttt{survey.html}. Página del cuestionario.
\end{itemize}

\section{Manual del programador}

Para ejecutar el servidor local se necesita tener instalado Python 3 y contar con 2 Gigabytes de espacio libre, tanto en disco como en memoria RAM.

Todos los \textit{scripts} están acompañados de un texto que indica cómo usarlos, y que se muestra si se ejecuta el archivo sin especificar ningún parámetro adicional. Además, es posible encontrar comentarios y nombres descriptivos que ilustran el cometido del archivo.

Por razones de universalidad en el acceso al conocimiento, pragmatismo y eficiencia, y con la intención de que el código pueda ser leído, entendido, mantenido o contribuido por personas de cualquier parte del mundo, todos los archivos de programación están escritos en inglés, al igual que las fichas que describen las funciones del sistema (\textit{issues}) en GitHub.

\section{Compilación, instalación y ejecución del proyecto}

Para ejecutar el proyecto localmente se ejecutarán los siguientes comandos desde el directorio \texttt{Web}:

\begin{verbatim}
pip install -r requirements.txt
python3 main.py mode=debug
\end{verbatim}

El primer comando usa el gestor de paquetes Pip de Python para instalar todas las dependencias necesarias del sistema; mientras que el segundo inicia la aplicación localmente (modo \texttt{debug}). Esto es necesario ya que, de lo contrario, la aplicación estaría apuntando hacia el dominio real, por lo que, en realidad, sería equivalente a acceder al sitio en Internet. Para usar la aplicación localmente tan solo se debe acceder a la URL de Flask desde el dispositivo en el que se han ejecutado los comandos anteriores: localhost:5000.

Ejecutar \texttt{python3 main.py mode=production} es equivalente a ejecutar \texttt{python3 main.py}, que es la orden ejecutada automáticamente por App Engine durante el despliegue del sistema.

Las páginas de los municipios se generan accediendo, únicamente desde el modo \texttt{debug}, a localhost:5000/generate-municipalities-pages. En el ordenador del autor, un MacBook Pro de 13 pulgadas de 2016 con macOS 12.6 Monterey, un procesador de 3,1 GHz Intel Core i5 de doble núcleo, 16 Gigabytes de memoria RAM LPDDR3 a 2133 MHz y una tarjeta gráfica Intel Iris Graphics 550 1536 MB, este proceso lleva aproximadamente una hora y media.

Para desplegar el sistema en App Engine tan solo es necesario ejecutar el GitHub Action \texttt{Deploy to GAE}, como se muestra a continuación:

\imagen{deploy}{GitHub Action de despliegue a Google App Engine.}

\section{Pruebas del sistema}

Las pruebas manuales del sistema se pueden realizar accediendo al sitio en \texttt{localhost} e interactuando con él. Se puede obtener una vista de prueba dinámica de la página de municipio –sin necesidad de recrear todas las páginas de forma estática– entrando, únicamente desde el modo \texttt{debug}, a localhost:5000/test-municipality-page.